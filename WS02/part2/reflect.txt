// Lance Curi0
// 104319223
// lcurio@myseneca.ca
// September 24-2023
We examined the different aspects of copy and move semantics in this workshop since they are important in improving code performance, especially when managing resources. There are a number of reasons why copy and transfer procedures take such a long time apart.

When an object is copied, it goes through a deep copy process that requires allocating new memory, copying the contents of the source object, and releasing old memory. This procedure naturally takes a long time, especially when dealing with large or resource-demanding items.

On the other hand, using move semantics, resource ownership is transferred from a source object to a target object. Since they involve "moving" resource pointers rather than copying data, move semantics are more efficient. Move semantics allow much quicker execution times by reducing duplicate data copying and memory allocation. When dealing with large datasets or resource-intensive objects, this efficiency is very obvious. The specific use case and the desire for performance optimization determine which semantics, copy or move, should be used.

The input file (airport_data.csv) is read and the dynamic array is filled in two steps in the AirportLog constructor. The file is first opened, and a loop counts the amount of records (apart from the header) in the file. The size of the resulting dynamic array of Airport objects, which is constructed next, is equal to the number of records. Before reading and processing each line of actual airport data into the air array, the file is cleaned and its get pointer is reset. It makes sense to want to avoid reading the file again, however in this case it's difficult because the initial pass is required to calculate the array size depending on the number of records. An alternative strategy could involve creating the dynamic array based on the vector's size and populating it from the vector, potentially optimizing memory usage without further rereading. This would involve temporarily storing airport information in a dynamic data structure like a vector during the initial counting phase.

The C++ library has two separate clock types: steady_clock and system_clock, each of which has a different function. Their behavior is where they differ most from one another. The steady_clock is made to offer a steady and monotonically growing time measurement that is independent of system time adjustments, which makes it perfect for measuring code segments or measuring specific time periods where accurate timing is crucial. The system_clock, on the other hand, gives users access to the most recent changes to the system time, which may have occurred due to the system synchronizing with outside time sources or changing the start or end of daylight saving time. Since showing the current date and time requires wall-clock time, the system_clock is appropriate for such purposes. In conclusion, the decision between steady_clock and system_clock relies on the particular use case: steady_clock is chosen for accurate timing measurements, whereas system_clock is utilized when you need real-world time information.
